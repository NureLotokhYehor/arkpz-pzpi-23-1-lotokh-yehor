Міністерство освіти і науки України Харківський національний університет радіоелектроніки


Кафедра програмної інженерії








Звіт
З лабораторної роботи №4
З дисципліни «Аналіз та рефакторинг коду» на тему: «РОЗРОБКА IoT КЛІЄНТА»















Виконав
ст. гр. ПЗПІ-23-1
Лотох Єгор	Перевірив
ас. викладач каф. ПІ Дашенков Дмитро Сергійович








Харків 2025
 
1 МЕТА РОБОТИ

Розробити клієнт IoT для моніторингу стану тварин у клініках, який здійснює збір, аналіз та передачу даних на сервер відповідно до принципів Інтернету речей. Реалізувати бізнес-логіку для обробки медичних даних тварин, функціонал налаштування пристрою та забезпечити інтеграцію з серверною частиною системи.

2 ХІД РОБОТИ

В ході виконання лабораторної роботи було розроблено IoT-систему для моніторингу стану тварин на базі ESP32, яка збирає дані про температуру, активність та пульс тварини. Пристрій зчитує температуру з DS18B20, визначає активність за допомогою MPU6050 і обчислює пульс тварини через емульований генератор імпульсів. Дані відображаються на OLED-дисплеї, а також передаються на MQTT-брокер у форматі JSON для інтеграції з системою віддаленого моніторингу VetMonitor. Тестування пристрою здійснювалося через серійний монітор для перевірки з’єднання з Wi-Fi та 
2.1 Текстовий опис інженерних рішень
Програмний код IoT-пристрою реалізовано в Arduino IDE з використанням бібліотек WiFi.h для підключення до Wi-Fi, PubSubClient.h для передачі даних через MQTT, Wire.h, Adafruit_GFX.h та Adafruit_SSD1306.h для OLED-дисплея, DallasTemperature.h та OneWire.h для сенсора DS18B20, Adafruit_MPU6050.h для акселерометра і гіроскопа. Основні етапи роботи включають підключення до Wi-Fi з перевіркою стану з’єднання, збирання та обробку даних сенсорів, відображення інформації на OLED-дисплеї, передачу даних на MQTT-брокер у форматі JSON та логування діагностичної інформації через серійний монітор.
 
Рисунок 2.1.1 – Схема IoT-пристрою.

2.2 Фрагменти програмного коду наведено у додатку А

2.3 Налаштування IoT-клієнта
Підключення IoT-клієнта до Wi-Fi мережі та MQTT-брокера забезпечує передачу даних про стан тварин на сервер для віддаленого моніторингу. Після ініціалізації системи пристрій підключається до заданої Wi-Fi мережі та перевіряє стан з’єднання. У разі успішного підключення запускається робота сенсорів DS18B20 та MPU6050, а також ініціалізується обробка даних пульсометра. Конфігурація пристрою дозволяє автоматично відновлювати з’єднання з MQTT-брокером у разі його втрати, що забезпечує стабільну роботу системи. Налаштування клієнта включає визначення пінів для сенсорів, налаштування інтервалу зчитування та налаштування формату передачі даних у JSON.

2.4 UML Діаграми
Діаграма прецедентів IoT-клієнта
 
Рисунок 2.4.1 – UML діаграма прецедентів IoT-клієнта

Діаграма прецедентів демонструє взаємодію IoT-клієнта для моніторингу здоров’я тварин з користувачем, Wi-Fi мережею, MQTT-брокером, температурним сенсором, пульсометром та акселерометром. Основні прецеденти включають підключення до Wi-Fi, збір даних із сенсорів, обробку показників активності та пульсу тварини, формування структурованого повідомлення у форматі JSON та передачу його на MQTT-брокер для віддаленого моніторингу. 
Рисунок 2.4.2 – UML діаграма діяльності IoT-клієнта

Діаграма діяльності відображає послідовність роботи IoT-клієнта від запуску до передачі даних на сервер. Пристрій спочатку ініціалізує ESP32 та OLED-дисплей, підключається до Wi-Fi мережі та перевіряє статус з’єднання. Після успішного підключення ініціалізуються сенсори температури, пульсометра та акселерометра. IoT-клієнт у циклі збирає дані про температуру, пульс та активність тварини, обробляє їх та формує JSON-повідомлення для відправки на MQTT-брокер. У разі успішної передачі на дисплеї відображається підтвердження, а у разі помилки – повідомлення про збій. Цикл повторюється протягом роботи пристрою, забезпечуючи безперервний моніторинг стану тварин.

3 ВИСНОВКИ

У ході виконання лабораторної роботи було успішно створено IoT-клієнт для моніторингу стану тварин, який забезпечує точний збір, обробку та передачу даних про температуру, пульс та активність тварини. Завдяки використанню мікроконтролера ESP32 та сучасних сенсорів DS18B20 і MPU6050, пристрій дозволяє отримувати надійні та своєчасні показники стану тварин.
Налаштування IoT-клієнта для передачі даних через MQTT забезпечує стабільну інтеграцію з серверною частиною системи VetMonitor, що дозволяє реалізувати віддалений контроль за станом здоров’я тварин у клініках або на фермах. Використання JSON-формату даних забезпечує сумісність з іншими компонентами системи та спрощує подальшу обробку інформації.
Розроблений IoT-клієнт демонструє практичну цінність для ветеринарного моніторингу, оскільки дозволяє оперативно реагувати на зміни фізіологічних показників тварин та своєчасно приймати рішення щодо лікування або догляду. Пристрій може бути використаний у сучасних системах управління здоров’ям тварин, включаючи автоматизовані ферми, клініки та програми віддаленого спостереження.
Крім того, виконана робота підтверджує ефективність інтеграції IoT-технологій у медичний і ветеринарний сектор, показуючи, що такі рішення дозволяють підвищити точність моніторингу, зменшити людський фактор та забезпечити безперервний контроль стану тварин у режимі реального часу.
Таким чином, створений IoT-клієнт не лише виконує основні функції збору та обробки даних, але й може стати основою для подальшого розвитку систем розумного моніторингу, інтегруючи нові сенсори, алгоритми обробки даних та аналітичні модулі для прогнозування стану здоров’я тварин.
 
Додаток А

1.  #include <Wire.h>
2.  #include <Adafruit_GFX.h>
3.  #include <Adafruit_SSD1306.h>
4.  #include <DallasTemperature.h>
5.  #include <OneWire.h>
6.  #include <Adafruit_MPU6050.h>
7.  #include <WiFi.h>
8.  #include <PubSubClient.h>
9.
10. #define SCREEN_WIDTH 128
11. #define SCREEN_HEIGHT 64
12. #define OLED_RESET -1
13. Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
14.
15. Adafruit_MPU6050 mpu;
16. sensors_event_t accelerometer, gyroscope, temp;
17. const float STEP_THRESHOLD = 1.5;
18. float accMag, gyroMag;
19. int stepCount = 0;
20.
21. #define ONE_WIRE_BUS 23
22. OneWire oneWire(ONE_WIRE_BUS);
23. DallasTemperature temperatureSensors(&oneWire);
24.
25. #define PULSE_PIN 2
26. volatile uint16_t pulse = 0;
27. uint16_t count = 0;
28. float heartRate = 0;
29. const unsigned long SAMPLING_INTERVAL = 1000;
30.
31. const char* ssid = "Wokwi-GUEST";
32. const char* password = "";
33.
34. const char* mqtt_server = "broker.hivemq.com";
35. const int mqtt_port = 1883;
36. const char* mqtt_topic = "vetmonitor/animalData";
37.
38. WiFiClient espClient;
39. PubSubClient mqttClient(espClient);
40.
41. void IRAM_ATTR pulseISR() {
42.   pulse++;
43. }
44.
45. void setup() {
46.   Serial.begin(115200);
47.   if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)){
48.     Serial.println("OLED not found");
49.     while(true);
50.   }
51.   display.clearDisplay();
52.   display.setTextSize(1);
53.   display.setTextColor(SSD1306_WHITE);
54.
55.   WiFi.begin(ssid, password);
56.   while(WiFi.status() != WL_CONNECTED){
57.     delay(1000);
58.     Serial.println("Connecting to WiFi...");
59.   }
60.   Serial.println("WiFi connected");
61.
62.   temperatureSensors.begin();
63.   if(!mpu.begin()){
64.     Serial.println("MPU6050 Error!");
65.     while(true);
66.   }
67.
68.   pinMode(PULSE_PIN, INPUT);
69.   attachInterrupt(digitalPinToInterrupt(PULSE_PIN), pulseISR, RISING);
70.
71.   mqttClient.setServer(mqtt_server, mqtt_port);
72.   reconnectMQTT();
73. }
74.
75. void loop() {
76.   if(!mqttClient.connected()) reconnectMQTT();
77.   mqttClient.loop();
78.
79.   static unsigned long lastSample = 0;
80.   if(millis() - lastSample < SAMPLING_INTERVAL) return;
81.   lastSample = millis();
82.
83.   temperatureSensors.requestTemperatures();
84.   float temperature = temperatureSensors.getTempCByIndex(0);
85.
86.   count = pulse;
87.   pulse = 0;
88.   heartRate = map(count, 0, 220, 0, 220);
89.
90.   mpu.getEvent(&accelerometer, &gyroscope, &temp);
91.   accMag = sqrt(sq(accelerometer.acceleration.x) + sq(accelerometer.acceleration.y) + sq(accelerometer.acceleration.z));
92.   gyroMag = sqrt(sq(gyroscope.gyro.x) + sq(gyroscope.gyro.y) + sq(gyroscope.gyro.z));
93.
94.   if(accMag > STEP_THRESHOLD || gyroMag > STEP_THRESHOLD) stepCount++;
95.
96.   display.clearDisplay();
97.   display.setCursor(0,0);
98.   display.print("Temp: "); display.println(temperature);
99.   display.print("Pulse: "); display.println(heartRate);
100.  display.print("Activity: "); display.println(stepCount);
101.  display.display();
102.
103.  String payload = "{\"temperature\": " + String(temperature) +
104.                   ", \"pulse\": " + String(heartRate) +
105.                   ", \"activity\": " + String(stepCount) + "}";
106.  mqttClient.publish(mqtt_topic, payload.c_str());
107.  Serial.println("MQTT: " + payload);
108. }
109.
110. void reconnectMQTT() {
111.   while(!mqttClient.connected()){
112.     if(mqttClient.connect("ESP32Client")){
113.       mqttClient.subscribe(mqtt_topic);
114.     } else {
115.       delay(5000);
116.     }
117.   }
118. }

Посилання на відео: https://youtu.be/DUwudJJpSVw

